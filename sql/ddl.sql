-- CREATE TABLE ...
-- CREATE INDEX ...
-- CREATE VIEW ...
-- CREATE FUNCTION ...
-- CREATE TRIGGER ...

DROP SCHEMA public CASCADE;
CREATE SCHEMA public;

-- AZIENDA
CREATE TABLE AZIENDA (
    PartitaIVA VARCHAR(11) PRIMARY KEY,
    RagioneSociale VARCHAR(100) NOT NULL,
    Telefono VARCHAR(20),
    Email VARCHAR(100) NOT NULL UNIQUE,
    StatoCollaborazione VARCHAR(30)
);

-- SEDE
CREATE TABLE SEDE (
    IdSede SERIAL PRIMARY KEY,
    Paese VARCHAR(50),
    Citta VARCHAR(50),
    Via VARCHAR(100),
    NumeroCivico VARCHAR(10),
    CAP VARCHAR(10),
    PartitaIVA VARCHAR(11) NOT NULL,
    FOREIGN KEY (PartitaIVA) REFERENCES AZIENDA(PartitaIVA)
);

-- AUSILIO
CREATE TABLE AUSILIO (
    CodiceISO VARCHAR(20) PRIMARY KEY,
    Nome VARCHAR(100),
    Categoria VARCHAR(50),
    Dimensione VARCHAR(50),
    Descrizione TEXT,
    Prezzo NUMERIC(10,2),
    PartitaIVA VARCHAR(11) NOT NULL,
    NumeroAusiliDisponibili INTEGER DEFAULT 0,
    FOREIGN KEY (PartitaIVA) REFERENCES AZIENDA(PartitaIVA)
);

-- MATERIALE
CREATE TABLE MATERIALE (
    IdMateriale SERIAL PRIMARY KEY,
    Nome VARCHAR(50) NOT NULL
);

-- COMPOSIZIONE
CREATE TABLE COMPOSIZIONE (
    CodiceISO VARCHAR(20),
    IdMateriale INTEGER,
    Peso NUMERIC(8,2),
    PRIMARY KEY (CodiceISO, IdMateriale),
    FOREIGN KEY (CodiceISO) REFERENCES AUSILIO(CodiceISO),
    FOREIGN KEY (IdMateriale) REFERENCES MATERIALE(IdMateriale)
);

-- AUSILIO_EFFETTIVO
CREATE TABLE AUSILIO_EFFETTIVO (
    NumeroArt SERIAL PRIMARY KEY,
    EventualiNote TEXT,
    CodiceISO VARCHAR(20) NOT NULL,
    FOREIGN KEY (CodiceISO) REFERENCES AUSILIO(CodiceISO)
);

-- UTENTE
CREATE TABLE UTENTE (
    ID SERIAL PRIMARY KEY
);

-- UTENTE_REGISTRATO
CREATE TABLE UTENTE_REGISTRATO (
    ID INTEGER PRIMARY KEY,
    Nome VARCHAR(50),
    Cognome VARCHAR(50),
    CF CHAR(16) NOT NULL UNIQUE,
    Telefono VARCHAR(20),
    Email VARCHAR(100) NOT NULL UNIQUE,
    Password VARCHAR(255) NOT NULL,
    Indirizzo VARCHAR(150),
    FOREIGN KEY (ID) REFERENCES UTENTE(ID)
);

-- RICHIESTA_AUSILIO
CREATE TABLE RICHIESTA_AUSILIO (
    IdRichiesta SERIAL PRIMARY KEY,
    Data DATE NOT NULL,
    ID INTEGER NOT NULL,
    FOREIGN KEY (ID) REFERENCES UTENTE_REGISTRATO(ID)
);

-- RICHIESTO
CREATE TABLE RICHIESTO (
    IdRichiesta INTEGER,
    CodiceISO VARCHAR(20),
    PRIMARY KEY (IdRichiesta, CodiceISO),
    FOREIGN KEY (IdRichiesta) REFERENCES RICHIESTA_AUSILIO(IdRichiesta),
    FOREIGN KEY (CodiceISO) REFERENCES AUSILIO(CodiceISO)
);

-- CONSULTAZIONE
CREATE TABLE CONSULTAZIONE (
    IdConsultazione SERIAL PRIMARY KEY,
    Data DATE NOT NULL,
    ID INTEGER NOT NULL,
    FOREIGN KEY (ID) REFERENCES UTENTE(ID)
);

-- DOCUMENTO
CREATE TABLE DOCUMENTO (
    ISBN VARCHAR(20) PRIMARY KEY,
    Titolo VARCHAR(150) NOT NULL
);

-- CONSULTAZIONE_DOCUMENTO
CREATE TABLE CONSULTAZIONE_DOCUMENTO (
    IdConsultazione INTEGER,
    ISBN VARCHAR(20),
    PRIMARY KEY (IdConsultazione, ISBN),
    FOREIGN KEY (IdConsultazione) REFERENCES CONSULTAZIONE(IdConsultazione),
    FOREIGN KEY (ISBN) REFERENCES DOCUMENTO(ISBN)
);

-- CENTRO
CREATE TABLE CENTRO (
    IdCentro SERIAL PRIMARY KEY,
    Nome VARCHAR(100),
    Ente VARCHAR(100),
    Telefono VARCHAR(20),
    Email VARCHAR(100) NOT NULL UNIQUE,
    Via VARCHAR(100),
    NumeroCivico VARCHAR(10),
    CAP VARCHAR(10),
    NumProfessionisti INTEGER DEFAULT 0
);

-- PROFESSIONISTA
CREATE TABLE PROFESSIONISTA (
    CF CHAR(16) PRIMARY KEY,
    Nome VARCHAR(50),
    Cognome VARCHAR(50),
    Telefono VARCHAR(20),
    Email VARCHAR(100) NOT NULL UNIQUE,
    Specializzazione VARCHAR(100),
    StipendioNetto NUMERIC(10,2),
    IdCentro INTEGER,
    FOREIGN KEY (IdCentro) REFERENCES CENTRO(IdCentro)
);

-- SUPERVISIONE
CREATE TABLE SUPERVISIONE (
    IdCentro INTEGER UNIQUE,
    CF CHAR(16),
    PRIMARY KEY (IdCentro, CF),
    FOREIGN KEY (IdCentro) REFERENCES CENTRO(IdCentro),
    FOREIGN KEY (CF) REFERENCES PROFESSIONISTA(CF)
);

-- VISITA
CREATE TABLE VISITA (
    IdVisita SERIAL PRIMARY KEY,
    Data DATE NOT NULL,
    Ora TIME NOT NULL,
    IdCentro INTEGER NOT NULL,
    CF CHAR(16) NOT NULL,
    FOREIGN KEY (IdCentro) REFERENCES CENTRO(IdCentro),
    FOREIGN KEY (CF) REFERENCES PROFESSIONISTA(CF)
);

-- SVOLGIMENTO
CREATE TABLE SVOLGIMENTO (
    IdVisita INTEGER PRIMARY KEY,
    ID INTEGER,
    Certificato BOOLEAN,
    FOREIGN KEY (IdVisita) REFERENCES VISITA(IdVisita),
    FOREIGN KEY (ID) REFERENCES UTENTE_REGISTRATO(ID)
);


-- SCRITTURA
CREATE TABLE SCRITTURA (
    ISBN VARCHAR(20),
    CF CHAR(16),
    PRIMARY KEY (ISBN, CF),
    FOREIGN KEY (ISBN) REFERENCES DOCUMENTO(ISBN),
    FOREIGN KEY (CF) REFERENCES PROFESSIONISTA(CF)
);

CREATE TABLE SEGNALAZIONE (
  IdSegnalazione SERIAL PRIMARY KEY,
  Titolo VARCHAR(150) NOT NULL,
  Descrizione TEXT,
  ID INTEGER NOT NULL REFERENCES UTENTE(ID),
  CodiceISO VARCHAR(20) REFERENCES AUSILIO(CodiceISO)
);

-- INDEXES
/*Indice standard (btree)
CREATE INDEX IF NOT EXISTS idx_<tabella>_<colonne>
ON <TABELLANOME> (<col1>, <col2>);
*/
-- ON ALL FK
CREATE INDEX IF NOT EXISTS idx_sede_partitaiva
ON SEDE (PartitaIVA);

CREATE INDEX IF NOT EXISTS idx_ausilio_partitaiva
ON AUSILIO (PartitaIVA);

CREATE INDEX IF NOT EXISTS idx_composizione_idmateriale
ON COMPOSIZIONE (IdMateriale);

CREATE INDEX IF NOT EXISTS idx_ausilio_effettivo_codiceiso
ON AUSILIO_EFFETTIVO (CodiceISO);

CREATE INDEX IF NOT EXISTS idx_richiesta_ausilio_id
ON RICHIESTA_AUSILIO (ID);

CREATE INDEX IF NOT EXISTS idx_richiesto_codiceiso
ON RICHIESTO (CodiceISO);

CREATE INDEX IF NOT EXISTS idx_consultazione_id
ON CONSULTAZIONE (ID);

CREATE INDEX IF NOT EXISTS idx_consultazione_documento_isbn
ON CONSULTAZIONE_DOCUMENTO (ISBN);

CREATE INDEX IF NOT EXISTS idx_professionista_idcentro
ON PROFESSIONISTA (IdCentro);

CREATE INDEX IF NOT EXISTS idx_supervisione_cf
ON SUPERVISIONE (CF);

CREATE INDEX IF NOT EXISTS idx_visita_idcentro
ON VISITA (IdCentro);

CREATE INDEX IF NOT EXISTS idx_svolgimento_id
ON SVOLGIMENTO (ID);

CREATE INDEX IF NOT EXISTS idx_scrittura_cf
ON SCRITTURA (CF);

--CHECK constraints
--Vincolo 1
ALTER TABLE PROFESSIONISTA
ADD CONSTRAINT chk_stipendio_prof_min
CHECK (StipendioNetto >= 1400);
--Vincolo 2
CREATE OR REPLACE FUNCTION chk_password_len()
RETURNS TRIGGER AS $$
BEGIN
  IF length(NEW.Password) < 4 THEN
    RAISE EXCEPTION 'Password troppo corta';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_chk_password_len
BEFORE INSERT OR UPDATE ON UTENTE_REGISTRATO
FOR EACH ROW EXECUTE FUNCTION chk_password_len();
--Vincolo 2.1 hashing password
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE OR REPLACE FUNCTION hash_password()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.Password NOT LIKE '$2%' THEN
    NEW.Password := crypt(NEW.Password, gen_salt('bf'));
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_hash_password
BEFORE INSERT OR UPDATE OF Password ON UTENTE_REGISTRATO
FOR EACH ROW EXECUTE FUNCTION hash_password();
--Vincolo 3
CREATE OR REPLACE FUNCTION chk_stipendio_admin()
RETURNS TRIGGER AS $$
DECLARE
  v_idcentro INTEGER;
  v_cf CHAR(16);
BEGIN
  -- chiamata da SUPERVISIONE
  IF TG_TABLE_NAME = 'supervisione' THEN
    v_idcentro := NEW.IdCentro;
    v_cf := NEW.CF;
  ELSE
    -- chiamata da PROFESSIONISTA
    v_idcentro := NEW.IdCentro;
    v_cf := NEW.CF;

    -- se non è supervisore, esci
    IF NOT EXISTS (
      SELECT 1 FROM SUPERVISIONE WHERE CF = v_cf
    ) THEN
      RETURN NEW;
    END IF;
  END IF;

  IF (
    SELECT StipendioNetto
    FROM PROFESSIONISTA
    WHERE CF = v_cf
  ) <= (
    SELECT MAX(StipendioNetto)
    FROM PROFESSIONISTA
    WHERE IdCentro = v_idcentro
      AND CF <> v_cf
  ) THEN
    RAISE EXCEPTION 'Stipendio amministratore non valido';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--called when Amministratore e' assegnato a un determinato centro
CREATE TRIGGER trg_chk_stipendio_admin_sup
AFTER INSERT OR UPDATE ON SUPERVISIONE
FOR EACH ROW
EXECUTE FUNCTION chk_stipendio_admin();
--called when professionista cambia stipendio
CREATE TRIGGER trg_chk_stipendio_admin_prof
BEFORE UPDATE OF StipendioNetto ON PROFESSIONISTA
FOR EACH ROW
EXECUTE FUNCTION chk_stipendio_admin();

--Vincolo 4
CREATE OR REPLACE FUNCTION chk_supervisione()
RETURNS TRIGGER AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM PROFESSIONISTA
    WHERE CF = NEW.CF AND IdCentro = NEW.IdCentro
  ) THEN
    RAISE EXCEPTION 'Centro non valido';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_chk_supervisione
BEFORE INSERT OR UPDATE ON SUPERVISIONE
FOR EACH ROW EXECUTE FUNCTION chk_supervisione();
--Vincolo 5 verra garantito dalla procedura di creazione richiesta ausilio

--Corretteza dati derivati 
--N ausili disponibili in AUSILIO
CREATE OR REPLACE FUNCTION ricalcola_ausili_disponibili()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE AUSILIO
  SET NumeroAusiliDisponibili = (
    SELECT COUNT(*)
    FROM AUSILIO_EFFETTIVO
    WHERE CodiceISO = COALESCE(NEW.CodiceISO, OLD.CodiceISO)
  )
  WHERE CodiceISO = COALESCE(NEW.CodiceISO, OLD.CodiceISO);

  RETURN NULL;
END;
$$;

--N professionisti in CENTRO
CREATE OR REPLACE FUNCTION ricalcola_num_professionisti()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE CENTRO
  SET NumProfessionisti = (
    SELECT COUNT(*)
    FROM PROFESSIONISTA
    WHERE IdCentro = COALESCE(NEW.IdCentro, OLD.IdCentro)
  )
  WHERE IdCentro = COALESCE(NEW.IdCentro, OLD.IdCentro);

  RETURN NULL;
END;
$$;
--chiamata trigger per garantire correttezza dati derivati
-- AUSILIO_EFFETTIVO → aggiorna NumeroAusiliDisponibili
CREATE TRIGGER trg_ricalcola_ausili_ins
AFTER INSERT OR DELETE OR UPDATE ON AUSILIO_EFFETTIVO
FOR EACH ROW EXECUTE FUNCTION ricalcola_ausili_disponibili();

-- PROFESSIONISTA → aggiorna NumProfessionisti
CREATE TRIGGER trg_ricalcola_prof_ins
AFTER INSERT OR DELETE OR UPDATE OF IdCentro
ON PROFESSIONISTA
FOR EACH ROW EXECUTE FUNCTION ricalcola_num_professionisti();

--funz di scegliere coso
